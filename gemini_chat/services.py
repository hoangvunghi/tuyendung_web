from django.conf import settings
from django.db import transaction
from django.db.models import Q, Count
from django.utils import timezone
from datetime import datetime

from enterprises.models import EnterpriseEntity, PostEntity, FieldEntity, PositionEntity, CriteriaEntity
from profiles.models import Cv, UserInfo
from accounts.models import UserAccount, UserRole
from .models import GeminiChatSession, GeminiChatMessage

import google.generativeai as genai
import uuid
import re
import json
import os
import logging

# C·∫•u h√¨nh Google Generative AI API
genai.configure(api_key=settings.GEMINI_API_KEY)

class GeminiChatService:
    """Service ƒë·ªÉ t∆∞∆°ng t√°c v·ªõi Gemini API v√† qu·∫£n l√Ω chat"""
    
    def __init__(self):
        """Kh·ªüi t·∫°o Gemini Chat Service"""
        self.logger = logging.getLogger(__name__)
        
        # C·∫•u h√¨nh generation
        self.generation_config = {
            "temperature": 0.7,
            "top_p": 0.95,
            "top_k": 40,
            "max_output_tokens": 8192,
        }
        
        # C·∫•u h√¨nh an to√†n
        self.safety_settings = [
            {
                "category": "HARM_CATEGORY_HARASSMENT",
                "threshold": "BLOCK_MEDIUM_AND_ABOVE"
            },
            {
                "category": "HARM_CATEGORY_HATE_SPEECH",
                "threshold": "BLOCK_MEDIUM_AND_ABOVE"
            },
            {
                "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                "threshold": "BLOCK_MEDIUM_AND_ABOVE"
            },
            {
                "category": "HARM_CATEGORY_DANGEROUS_CONTENT",
                "threshold": "BLOCK_MEDIUM_AND_ABOVE"
            },
        ]
        
        self.model_name = "gemini-2.0-flash"
    
    def get_system_prompt(self, user):
        """T·∫°o system prompt d·ª±a tr√™n vai tr√≤ c·ªßa user"""
        current_time = datetime.now().strftime("%d/%m/%Y %H:%M:%S")
        
        base_prompt = f"""B·∫°n l√† tr·ª£ l√Ω AI h·ªó tr·ª£ ng∆∞·ªùi d√πng tr√™n website tuy·ªÉn d·ª•ng 'JobHub'. Hi·ªán t·∫°i l√† {current_time}.

H∆Ø·ªöNG D·∫™N TRUY V·∫§N D·ªÆ LI·ªÜU:
1. ∆ØU TI√äN D·ªÆ LI·ªÜU TRONG WEBSITE khi nh·∫≠n ƒë∆∞·ª£c c√¢u h·ªèi v·ªÅ:
   - Vi·ªác l√†m hi·ªán c√≥ tr√™n trang web (v·ªã tr√≠, m·ª©c l∆∞∆°ng, kinh nghi·ªám, ƒë·ªãa ƒëi·ªÉm, ng√†nh ngh·ªÅ...)
   - Th√¥ng tin doanh nghi·ªáp ƒëƒÉng tuy·ªÉn tr√™n trang web
   - Th√¥ng tin ·ª©ng vi√™n, h·ªì s∆° tuy·ªÉn d·ª•ng trong h·ªá th·ªëng
   - Th·ªëng k√™, s·ªë li·ªáu v·ªÅ vi·ªác l√†m tr√™n trang web
   - B·∫•t k·ª≥ c√¢u h·ªèi n√†o ƒë·ªÅ c·∫≠p ƒë·∫øn "tr√™n trang web", "trong h·ªá th·ªëng", "hi·ªán c√≥", "ƒëang tuy·ªÉn"

2. CH·ªà T√åM KI·∫æM INTERNET khi:
   - C√¢u h·ªèi v·ªÅ ki·∫øn th·ª©c chung kh√¥ng li√™n quan ƒë·∫øn d·ªØ li·ªáu c·ª• th·ªÉ tr√™n trang web
   - C√¢u h·ªèi v·ªÅ k·ªπ nƒÉng vi·∫øt CV, ph·ªèng v·∫•n, ph√°t tri·ªÉn ngh·ªÅ nghi·ªáp
   - C√¢u h·ªèi v·ªÅ xu h∆∞·ªõng th·ªã tr∆∞·ªùng vi·ªác l√†m n√≥i chung
   - C√¢u h·ªèi ch·ªâ r√µ y√™u c·∫ßu t√¨m ki·∫øm th√¥ng tin t·ª´ internet

3. C√ÅC Y√äU C·∫¶U KH√ÅC:
   - Tr·∫£ l·ªùi ng·∫Øn g·ªçn, r√µ r√†ng, l·ªãch s·ª± v√† th√¢n thi·ªán
   - H·ªó tr·ª£ ng∆∞·ªùi d√πng t√¨m ki·∫øm vi·ªác l√†m ph√π h·ª£p v·ªõi nhu c·∫ßu v√† k·ªπ nƒÉng
   - Kh√¥ng cung c·∫•p th√¥ng tin sai l·ªách ho·∫∑c g√¢y hi·ªÉu nh·∫ßm
   - Kh√¥ng th·ª±c hi·ªán h√†nh ƒë·ªông tr√°i v·ªõi ƒë·∫°o ƒë·ª©c ho·∫∑c quy ƒë·ªãnh ph√°p lu·∫≠t
   - T√¥n tr·ªçng t√≠nh ri√™ng t∆∞ v√† b·∫£o m·∫≠t th√¥ng tin ng∆∞·ªùi d√πng
   - Lu√¥n th√¥ng b√°o khi n·ªôi dung tr·∫£ l·ªùi t·ª´ database ho·∫∑c t·ª´ internet

TH√îNG TIN V·ªÄ WEBSITE JobHub:
- Website tuy·ªÉn d·ª•ng vi·ªác l√†m uy t√≠n v·ªõi nhi·ªÅu ng√†nh ngh·ªÅ
- K·∫øt n·ªëi doanh nghi·ªáp v√† ·ª©ng vi√™n t√¨m vi·ªác
- Cung c·∫•p c√°c c√¥ng c·ª• t√¨m ki·∫øm vi·ªác l√†m, ƒëƒÉng tuy·ªÉn, qu·∫£n l√Ω h·ªì s∆°
- H·ªó tr·ª£ c·∫£ ng∆∞·ªùi t√¨m vi·ªác v√† nh√† tuy·ªÉn d·ª•ng
- C√≥ c√°c g√≥i d·ªãch v·ª• premium cho ng∆∞·ªùi d√πng

Khi c√≥ y√™u c·∫ßu cung c·∫•p th√¥ng tin t·ª´ database, h√£y s·ª≠ d·ª•ng d·ªØ li·ªáu t√¥i cung c·∫•p. 
N·∫øu kh√¥ng c√≥ d·ªØ li·ªáu ho·∫∑c y√™u c·∫ßu kh√¥ng li√™n quan ƒë·∫øn d·ªØ li·ªáu c·ªßa h·ªá th·ªëng, h√£y t√¨m ki·∫øm th√¥ng tin ph√π h·ª£p tr√™n internet."""

        if user.is_employer():
            employer_prompt = f"""
TH√îNG TIN D√ÄNH CHO NH√Ä TUY·ªÇN D·ª§NG:
- B·∫°n c√≥ th·ªÉ truy v·∫•n v·ªÅ c√°c ·ª©ng vi√™n ƒë√£ ·ª©ng tuy·ªÉn v√†o v·ªã tr√≠ c·ªßa b·∫°n
- T√¥i c√≥ th·ªÉ h·ªó tr·ª£ b·∫°n ƒëƒÉng tin tuy·ªÉn d·ª•ng v√† qu·∫£n l√Ω h·ªì s∆° ·ª©ng vi√™n
- T√¥i c√≥ th·ªÉ cung c·∫•p th·ªëng k√™ v·ªÅ hi·ªáu qu·∫£ tin tuy·ªÉn d·ª•ng c·ªßa b·∫°n
- T√¥i c√≥ th·ªÉ gi√∫p b·∫°n l√™n chi·∫øn l∆∞·ª£c tuy·ªÉn d·ª•ng hi·ªáu qu·∫£
- T√¥i c√≥ th·ªÉ h·ªó tr·ª£ b·∫°n n√¢ng c·∫•p t√†i kho·∫£n premium"""
            return base_prompt + employer_prompt
        else:
            job_seeker_prompt = f"""
TH√îNG TIN D√ÄNH CHO NG∆Ø·ªúI T√åM VI·ªÜC:
- B·∫°n c√≥ th·ªÉ truy v·∫•n v·ªÅ vi·ªác l√†m ph√π h·ª£p v·ªõi k·ªπ nƒÉng c·ªßa b·∫°n
- T√¥i c√≥ th·ªÉ gi√∫p b·∫°n t√¨m vi·ªác l√†m theo ƒë·ªãa ƒëi·ªÉm, m·ª©c l∆∞∆°ng, ng√†nh ngh·ªÅ
- T√¥i c√≥ th·ªÉ h·ªó tr·ª£ b·∫°n theo d√µi tr·∫°ng th√°i h·ªì s∆° ·ª©ng tuy·ªÉn
- T√¥i c√≥ th·ªÉ gi√∫p b·∫°n n√¢ng cao c∆° h·ªôi ƒë∆∞·ª£c tuy·ªÉn d·ª•ng
- T√¥i c√≥ th·ªÉ h·ªó tr·ª£ b·∫°n n√¢ng c·∫•p t√†i kho·∫£n premium"""
            return base_prompt + job_seeker_prompt
    
    def _get_enterprise_job_posts(self, enterprise):
        """L·∫•y th√¥ng tin b√†i ƒëƒÉng tuy·ªÉn d·ª•ng c·ªßa doanh nghi·ªáp"""
        if not enterprise:
            return "Kh√¥ng c√≥ d·ªØ li·ªáu tin tuy·ªÉn d·ª•ng"
            
        # L·∫•y 5 b√†i ƒëƒÉng g·∫ßn nh·∫•t
        posts = PostEntity.objects.filter(enterprise=enterprise).order_by('-created_at')[:5]
        
        if not posts:
            return "Doanh nghi·ªáp ch∆∞a c√≥ tin tuy·ªÉn d·ª•ng n√†o"
            
        posts_info = []
        for post in posts:
            # ƒê·∫øm s·ªë ƒë∆°n ·ª©ng tuy·ªÉn
            cv_count = Cv.objects.filter(post=post).count()
            
            posts_info.append(f"""
            - Ti√™u ƒë·ªÅ: {post.title}
            - V·ªã tr√≠: {post.position.name if post.position else ""}
            - Kinh nghi·ªám: {post.experience}
            - L∆∞∆°ng: {f"T·ª´ {post.salary_min} ƒë·∫øn {post.salary_max} tri·ªáu" if not post.is_salary_negotiable else "Th·ªèa thu·∫≠n"}
            - Th√†nh ph·ªë: {post.city}
            - S·ªë l∆∞·ª£ng ·ª©ng vi√™n ƒë√£ ·ª©ng tuy·ªÉn: {cv_count}
            - Tr·∫°ng th√°i: {"ƒêang hi·ªÉn th·ªã" if post.is_active else "Ch∆∞a ƒëƒÉng"}
            """)
        
        return "M·ªôt s·ªë tin tuy·ªÉn d·ª•ng g·∫ßn ƒë√¢y:\n" + "\n".join(posts_info)
    
    def search_job_posts(self, query=None, city=None, experience=None, position_id=None, limit=5):
        """T√¨m ki·∫øm vi·ªác l√†m d·ª±a tr√™n c√°c ti√™u ch√≠"""
        from enterprises.models import PostEntity
        
        posts = PostEntity.objects.filter(is_active=True)
        
        # L·ªçc theo t·ª´ kh√≥a t√¨m ki·∫øm
        if query and query.strip():
            query_terms = query.split()
            q_object = Q()
            
            for term in query_terms:
                q_object |= (
                    Q(title__icontains=term) | 
                    Q(description__icontains=term) | 
                    Q(required__icontains=term) |
                    Q(interest__icontains=term) |
                    Q(position__name__icontains=term) |
                    Q(field__name__icontains=term) |
                    Q(enterprise__company_name__icontains=term)
                )
            
            posts = posts.filter(q_object)
        
        # L·ªçc theo th√†nh ph·ªë
        if city:
            posts = posts.filter(city__icontains=city)
        
        # L·ªçc theo kinh nghi·ªám
        if experience:
            posts = posts.filter(experience__icontains=experience)
        
        # L·ªçc theo v·ªã tr√≠ c√¥ng vi·ªác
        if position_id:
            posts = posts.filter(position_id=position_id)
        
        # S·∫Øp x·∫øp k·∫øt qu·∫£ (m·ªõi nh·∫•t tr∆∞·ªõc)
        posts = posts.order_by('-created_at')
        
        # Gi·ªõi h·∫°n s·ªë l∆∞·ª£ng k·∫øt qu·∫£
        posts = posts[:limit]
        
        # Format k·∫øt qu·∫£
        if not posts:
            return "Kh√¥ng t√¨m th·∫•y vi·ªác l√†m ph√π h·ª£p v·ªõi ti√™u ch√≠ c·ªßa b·∫°n."
        
        results = []
        for post in posts:
            post_info = {
                'id': post.id,
                'title': post.title,
                'company': post.enterprise.company_name,
                'city': post.city,
                'salary': f"{post.salary_min} - {post.salary_max} tri·ªáu VND" if post.salary_min and post.salary_max else "Th·ªèa thu·∫≠n",
                'experience': post.experience,
                'job_type': post.type_working,
                'position': post.position.name if post.position else "",
                'field': post.field.name if post.field else "",
                'created_at': post.created_at.strftime('%d/%m/%Y'),
                'deadline': post.deadline.strftime('%d/%m/%Y') if post.deadline else ""
            }
            results.append(post_info)
        
        # Format k·∫øt qu·∫£ th√†nh markdown
        markdown_result = "### K·∫øt qu·∫£ t√¨m ki·∫øm vi·ªác l√†m\n\n"
        
        for job in results:
            markdown_result += f"#### [{job['title']}](job/{job['id']})\n"
            markdown_result += f"üè¢ **C√¥ng ty:** {job['company']}\n"
            markdown_result += f"üìç **ƒê·ªãa ƒëi·ªÉm:** {job['city']}\n"
            markdown_result += f"üí∞ **M·ª©c l∆∞∆°ng:** {job['salary']}\n"
            markdown_result += f"üìä **Kinh nghi·ªám:** {job['experience']}\n"
            markdown_result += f"üîñ **Lo·∫°i c√¥ng vi·ªác:** {job['job_type']}\n"
            markdown_result += f"üìå **V·ªã tr√≠:** {job['position']}\n"
            markdown_result += f"üè≠ **Lƒ©nh v·ª±c:** {job['field']}\n"
            markdown_result += f"üìÖ **Ng√†y ƒëƒÉng:** {job['created_at']}\n"
            if job['deadline']:
                markdown_result += f"‚è∞ **H·∫°n n·ªôp h·ªì s∆°:** {job['deadline']}\n"
            markdown_result += f"üîó **Xem chi ti·∫øt:** [ID: {job['id']}](job/{job['id']})\n\n"
            markdown_result += "---\n\n"
        
        return markdown_result.strip()
    
    def search_candidates(self, query, city=None, experience=None, position_id=None, limit=5):
        """T√¨m ki·∫øm ·ª©ng vi√™n d·ª±a tr√™n t·ª´ kh√≥a v√† c√°c ti√™u ch√≠"""
        # Ch·ªâ d√†nh cho nh√† tuy·ªÉn d·ª•ng c√≥ quy·ªÅn premium
        
        # T·∫°o query t√¨m ki·∫øm CV
        criteria_query = Q()
        
        if city:
            criteria_query |= Q(city=city)
            
        if experience:
            criteria_query |= Q(experience=experience)
            
        if position_id:
            criteria_query |= Q(position_id=position_id)
            
        # T√¨m ki·∫øm ti√™u ch√≠ ph√π h·ª£p
        criteria = CriteriaEntity.objects.filter(criteria_query)
        
        if not criteria:
            return "Kh√¥ng t√¨m th·∫•y ·ª©ng vi√™n ph√π h·ª£p v·ªõi y√™u c·∫ßu"
            
        # L·∫•y th√¥ng tin ·ª©ng vi√™n
        users = UserAccount.objects.filter(criteria__in=criteria).distinct()
        
        if not users:
            return "Kh√¥ng t√¨m th·∫•y ·ª©ng vi√™n ph√π h·ª£p v·ªõi y√™u c·∫ßu"
            
        results = []
        for user in users[:limit]:
            user_info = UserInfo.objects.filter(user=user).first()
            user_criteria = CriteriaEntity.objects.filter(user=user).first()
            
            if user_info:
                results.append(f"""
                - H·ªç t√™n: {user_info.fullname if user_info.fullname else user.username}
                - Email: {user.email}
                - Kinh nghi·ªám mong mu·ªën: {user_criteria.experience if user_criteria else "Kh√¥ng c√≥ th√¥ng tin"}
                - V·ªã tr√≠ mong mu·ªën: {user_criteria.position.name if user_criteria and user_criteria.position else "Kh√¥ng c√≥ th√¥ng tin"}
                - Th√†nh ph·ªë: {user_criteria.city if user_criteria else "Kh√¥ng c√≥ th√¥ng tin"}
                """)
                
        if not results:
            return "Kh√¥ng t√¨m th·∫•y ·ª©ng vi√™n ph√π h·ª£p v·ªõi y√™u c·∫ßu"
            
        return "K·∫øt qu·∫£ t√¨m ki·∫øm ·ª©ng vi√™n:\n" + "\n".join(results)
    
    def get_job_recommendation(self, user):
        """G·ª£i √Ω vi·ªác l√†m d·ª±a tr√™n ti√™u ch√≠ c·ªßa ng∆∞·ªùi d√πng"""
        # Ch·ªâ th·ª±c hi·ªán cho ng∆∞·ªùi d√πng ƒë√£ ƒëƒÉng nh·∫≠p v√† l√† ·ª©ng vi√™n
        if not user.is_authenticated or user.is_employer():
            return "Vui l√≤ng ƒëƒÉng nh·∫≠p v·ªõi t√†i kho·∫£n ·ª©ng vi√™n ƒë·ªÉ nh·∫≠n g·ª£i √Ω vi·ªác l√†m ph√π h·ª£p."
        
        try:
            from enterprises.models import CriteriaEntity, PostEntity
            
            # L·∫•y ti√™u ch√≠ t√¨m vi·ªác c·ªßa ng∆∞·ªùi d√πng
            criteria = CriteriaEntity.objects.get(user=user)
            
            # T·∫°o truy v·∫•n c∆° b·∫£n (ch·ªâ l·∫•y c√°c vi·ªác l√†m ƒëang ho·∫°t ƒë·ªông)
            query = Q(status=True)
            
            # L·ªçc theo th√†nh ph·ªë
            if criteria.city:
                query &= Q(city__icontains=criteria.city)
            
            # L·ªçc theo v·ªã tr√≠ c√¥ng vi·ªác
            if criteria.position:
                query &= Q(position=criteria.position)
            
            # L·ªçc theo lƒ©nh v·ª±c
            if criteria.field:
                query &= Q(field=criteria.field)
            
            # L·ªçc theo lo·∫°i c√¥ng vi·ªác
            if criteria.type_working:
                query &= Q(type_working__icontains=criteria.type_working)
            
            # L·ªçc theo m·ª©c l∆∞∆°ng t·ªëi thi·ªÉu
            if criteria.salary_min:
                query &= Q(salary_min__gte=criteria.salary_min)
            
            # L·ªçc theo kinh nghi·ªám
            if criteria.experience:
                query &= Q(experience__icontains=criteria.experience)
            
            # Th·ª±c hi·ªán truy v·∫•n
            posts = PostEntity.objects.filter(query).order_by('-created_at')[:5]
            
            if not posts:
                return "Kh√¥ng t√¨m th·∫•y vi·ªác l√†m ph√π h·ª£p v·ªõi ti√™u ch√≠ c·ªßa b·∫°n."
            
            results = []
            for post in posts:
                post_info = {
                    'id': post.id,
                    'title': post.title,
                    'company': post.enterprise.company_name,
                    'city': post.city,
                    'salary': f"{post.salary_min} - {post.salary_max} tri·ªáu VND" if post.salary_min and post.salary_max else "Th·ªèa thu·∫≠n",
                    'experience': post.experience,
                    'job_type': post.type_working,
                    'position': post.position.name if post.position else "",
                    'field': post.field.name if post.field else "",
                    'created_at': post.created_at.strftime('%d/%m/%Y'),
                    'deadline': post.deadline.strftime('%d/%m/%Y') if post.deadline else ""
                }
                results.append(post_info)
            
            # Format k·∫øt qu·∫£ th√†nh markdown
            markdown_result = "### Vi·ªác l√†m ph√π h·ª£p v·ªõi b·∫°n\n\n"
            
            markdown_result += "D·ª±a tr√™n ti√™u ch√≠ t√¨m vi·ªác c·ªßa b·∫°n:\n"
            markdown_result += f"- üìç **Th√†nh ph·ªë:** {criteria.city if criteria.city else 'Kh√¥ng'}\n"
            markdown_result += f"- üìå **V·ªã tr√≠:** {criteria.position.name if criteria.position else 'Kh√¥ng'}\n"
            markdown_result += f"- üè≠ **Lƒ©nh v·ª±c:** {criteria.field.name if criteria.field else 'Kh√¥ng'}\n"
            markdown_result += f"- üîñ **Lo·∫°i c√¥ng vi·ªác:** {criteria.type_working if criteria.type_working else 'Kh√¥ng'}\n"
            markdown_result += f"- üìä **Kinh nghi·ªám:** {criteria.experience if criteria.experience else 'Kh√¥ng'}\n"
            markdown_result += f"- üí∞ **M·ª©c l∆∞∆°ng t·ªëi thi·ªÉu:** {criteria.salary_min} tri·ªáu VND\n\n"
            
            markdown_result += "T√¥i t√¨m th·∫•y c√°c vi·ªác l√†m ph√π h·ª£p sau:\n\n"
            
            for job in results:
                markdown_result += f"#### [{job['title']}](job/{job['id']})\n"
                markdown_result += f"üè¢ **C√¥ng ty:** {job['company']}\n"
                markdown_result += f"üìç **ƒê·ªãa ƒëi·ªÉm:** {job['city']}\n"
                markdown_result += f"üí∞ **M·ª©c l∆∞∆°ng:** {job['salary']}\n"
                markdown_result += f"üìä **Kinh nghi·ªám:** {job['experience']}\n"
                markdown_result += f"üîñ **Lo·∫°i c√¥ng vi·ªác:** {job['job_type']}\n"
                markdown_result += f"üìå **V·ªã tr√≠:** {job['position']}\n"
                markdown_result += f"üè≠ **Lƒ©nh v·ª±c:** {job['field']}\n"
                markdown_result += f"üìÖ **Ng√†y ƒëƒÉng:** {job['created_at']}\n"
                if job['deadline']:
                    markdown_result += f"‚è∞ **H·∫°n n·ªôp h·ªì s∆°:** {job['deadline']}\n"
                markdown_result += f"üîó **Xem chi ti·∫øt:** [ID: {job['id']}](job/{job['id']})\n\n"
                markdown_result += "---\n\n"
            
            return markdown_result.strip()
        
        except CriteriaEntity.DoesNotExist:
            return "B·∫°n ch∆∞a c·∫≠p nh·∫≠t ti√™u ch√≠ t√¨m vi·ªác. Vui l√≤ng v√†o m·ª•c 'Ti√™u ch√≠ t√¨m vi·ªác' ƒë·ªÉ c·∫≠p nh·∫≠t."
    
    def get_highest_paying_jobs(self, limit=5):
        """L·∫•y danh s√°ch vi·ªác l√†m c√≥ m·ª©c l∆∞∆°ng cao nh·∫•t"""
        from enterprises.models import PostEntity
        
        posts = PostEntity.objects.filter(is_active=True).order_by('-salary_max', '-salary_min')[:limit]
        
        if not posts:
            return "Kh√¥ng t√¨m th·∫•y th√¥ng tin v·ªÅ vi·ªác l√†m l∆∞∆°ng cao nh·∫•t."
        
        results = []
        for post in posts:
            post_info = {
                'id': post.id,
                'title': post.title,
                'company': post.enterprise.company_name,
                'city': post.city,
                'salary': f"{post.salary_min} - {post.salary_max} tri·ªáu VND" if post.salary_min and post.salary_max else "Th·ªèa thu·∫≠n",
                'experience': post.experience,
                'job_type': post.type_working,
                'position': post.position.name if post.position else "",
                'field': post.field.name if post.field else "",
                'created_at': post.created_at.strftime('%d/%m/%Y'),
                'deadline': post.deadline.strftime('%d/%m/%Y') if post.deadline else ""
            }
            results.append(post_info)
        
        # Format k·∫øt qu·∫£ th√†nh markdown
        markdown_result = "### C√°c c√¥ng vi·ªác c√≥ m·ª©c l∆∞∆°ng cao nh·∫•t\n\n"
        
        for job in results:
            markdown_result += f"#### [{job['title']}](job/{job['id']})\n"
            markdown_result += f"üè¢ **C√¥ng ty:** {job['company']}\n"
            markdown_result += f"üìç **ƒê·ªãa ƒëi·ªÉm:** {job['city']}\n"
            markdown_result += f"üí∞ **M·ª©c l∆∞∆°ng:** {job['salary']}\n"
            markdown_result += f"üìä **Kinh nghi·ªám:** {job['experience']}\n"
            markdown_result += f"üîñ **Lo·∫°i c√¥ng vi·ªác:** {job['job_type']}\n"
            markdown_result += f"üìå **V·ªã tr√≠:** {job['position']}\n"
            markdown_result += f"üè≠ **Lƒ©nh v·ª±c:** {job['field']}\n"
            markdown_result += f"üìÖ **Ng√†y ƒëƒÉng:** {job['created_at']}\n"
            if job['deadline']:
                markdown_result += f"‚è∞ **H·∫°n n·ªôp h·ªì s∆°:** {job['deadline']}\n"
            markdown_result += f"üîó **Xem chi ti·∫øt:** [ID: {job['id']}](job/{job['id']})\n\n"
            markdown_result += "---\n\n"
        
        return markdown_result.strip()
    
    def get_most_recent_jobs(self, limit=5):
        """L·∫•y danh s√°ch vi·ªác l√†m m·ªõi ƒëƒÉng g·∫ßn ƒë√¢y"""
        from enterprises.models import PostEntity
        
        posts = PostEntity.objects.filter(is_active=True).order_by('-created_at')[:limit]
        
        if not posts:
            return "Kh√¥ng t√¨m th·∫•y th√¥ng tin v·ªÅ vi·ªác l√†m m·ªõi ƒëƒÉng."
        
        results = []
        for post in posts:
            post_info = {
                'id': post.id,
                'title': post.title,
                'company': post.enterprise.company_name,
                'city': post.city,
                'salary': f"{post.salary_min} - {post.salary_max} tri·ªáu VND" if post.salary_min and post.salary_max else "Th·ªèa thu·∫≠n",
                'experience': post.experience,
                'job_type': post.type_working,
                'position': post.position.name if post.position else "",
                'field': post.field.name if post.field else "",
                'created_at': post.created_at.strftime('%d/%m/%Y'),
                'deadline': post.deadline.strftime('%d/%m/%Y') if post.deadline else "",
                'days_ago': (timezone.now().date() - post.created_at.date()).days
            }
            results.append(post_info)
        
        # Format k·∫øt qu·∫£ th√†nh markdown
        markdown_result = "### C√°c vi·ªác l√†m m·ªõi ƒëƒÉng g·∫ßn ƒë√¢y\n\n"
        
        for job in results:
            days_text = f"{job['days_ago']} ng√†y tr∆∞·ªõc" if job['days_ago'] > 0 else "H√¥m nay"
            markdown_result += f"#### [{job['title']}](job/{job['id']}) - *{days_text}*\n"
            markdown_result += f"üè¢ **C√¥ng ty:** {job['company']}\n"
            markdown_result += f"üìç **ƒê·ªãa ƒëi·ªÉm:** {job['city']}\n"
            markdown_result += f"üí∞ **M·ª©c l∆∞∆°ng:** {job['salary']}\n"
            markdown_result += f"üìä **Kinh nghi·ªám:** {job['experience']}\n"
            markdown_result += f"üîñ **Lo·∫°i c√¥ng vi·ªác:** {job['job_type']}\n"
            markdown_result += f"üìå **V·ªã tr√≠:** {job['position']}\n"
            markdown_result += f"üè≠ **Lƒ©nh v·ª±c:** {job['field']}\n"
            if job['deadline']:
                markdown_result += f"‚è∞ **H·∫°n n·ªôp h·ªì s∆°:** {job['deadline']}\n"
            markdown_result += f"üîó **Xem chi ti·∫øt:** [ID: {job['id']}](job/{job['id']})\n\n"
            markdown_result += "---\n\n"
        
        return markdown_result.strip()
    
    def get_stats_data(self):
        """L·∫•y th·ªëng k√™ h·ªá th·ªëng"""
        from enterprises.models import PostEntity, EnterpriseEntity
        
        # ƒê·∫øm s·ªë l∆∞·ª£ng vi·ªác l√†m ƒëang ho·∫°t ƒë·ªông
        active_jobs_count = PostEntity.objects.filter(is_active=True).count()
        
        # ƒê·∫øm t·ªïng s·ªë vi·ªác l√†m
        total_jobs_count = PostEntity.objects.count()
        
        # ƒê·∫øm s·ªë l∆∞·ª£ng doanh nghi·ªáp
        enterprise_count = EnterpriseEntity.objects.count()
        
        # ƒê·∫øm s·ªë l∆∞·ª£ng ng∆∞·ªùi d√πng
        user_count = UserAccount.objects.count()
        
        # ƒê·∫øm s·ªë l∆∞·ª£ng ·ª©ng vi√™n (ng∆∞·ªùi d√πng c√≥ vai tr√≤ 'candidate')
        candidates_count = UserAccount.objects.filter(user_roles__role__name='candidate').count()
        
        # T√≠nh m·ª©c l∆∞∆°ng trung b√¨nh
        avg_salary_min = PostEntity.objects.filter(is_active=True, salary_min__isnull=False).values_list('salary_min', flat=True)
        avg_salary_max = PostEntity.objects.filter(is_active=True, salary_max__isnull=False).values_list('salary_max', flat=True)
        
        avg_min = round(sum(avg_salary_min) / len(avg_salary_min)) if avg_salary_min else 0
        avg_max = round(sum(avg_salary_max) / len(avg_salary_max)) if avg_salary_max else 0
        
        # Vi·ªác l√†m theo th√†nh ph·ªë
        city_stats = PostEntity.objects.filter(is_active=True).values('city').annotate(count=Count('city')).order_by('-count')[:5]
        
        # Vi·ªác l√†m theo lƒ©nh v·ª±c
        field_stats = PostEntity.objects.filter(is_active=True).values('field__name').annotate(count=Count('field')).order_by('-count')[:5]
        
        # Format k·∫øt qu·∫£ th√†nh markdown
        markdown_result = "### Th·ªëng k√™ h·ªá th·ªëng JobHub\n\n"
        
        markdown_result += "#### T·ªïng quan\n"
        markdown_result += f"- üìä **T·ªïng s·ªë vi·ªác l√†m ƒëang tuy·ªÉn:** {active_jobs_count}\n"
        markdown_result += f"- üìë **T·ªïng s·ªë tin tuy·ªÉn d·ª•ng:** {total_jobs_count}\n"
        markdown_result += f"- üè¢ **S·ªë l∆∞·ª£ng doanh nghi·ªáp:** {enterprise_count}\n"
        markdown_result += f"- üë• **S·ªë l∆∞·ª£ng ng∆∞·ªùi d√πng:** {user_count}\n"
        markdown_result += f"- üë®‚Äçüíº **S·ªë l∆∞·ª£ng ·ª©ng vi√™n:** {candidates_count}\n"
        
        markdown_result += "\n#### M·ª©c l∆∞∆°ng trung b√¨nh\n"
        markdown_result += f"- üí∞ **M·ª©c l∆∞∆°ng trung b√¨nh:** {avg_min} - {avg_max} tri·ªáu VND\n"
        
        markdown_result += "\n#### Top 5 th√†nh ph·ªë c√≥ nhi·ªÅu vi·ªác l√†m nh·∫•t\n"
        for city in city_stats:
            markdown_result += f"- üåÜ **{city['city']}:** {city['count']} vi·ªác l√†m\n"
        
        markdown_result += "\n#### Top 5 lƒ©nh v·ª±c c√≥ nhi·ªÅu vi·ªác l√†m nh·∫•t\n"
        for field in field_stats:
            if field['field__name']:
                markdown_result += f"- üè≠ **{field['field__name']}:** {field['count']} vi·ªác l√†m\n"
        
        return markdown_result.strip()
    
    @transaction.atomic
    def create_chat_session(self, user):
        """T·∫°o phi√™n chat m·ªõi cho ng∆∞·ªùi d√πng"""
        try:
            # T·∫°o phi√™n chat m·ªõi
            session = GeminiChatSession.objects.create(
                user=user,
                title="Phi√™n chat m·ªõi"
            )
            
            # Tr·∫£ v·ªÅ phi√™n chat
            return session
            
        except Exception as e:
            self.logger.error(f"L·ªói khi t·∫°o phi√™n chat: {str(e)}")
            raise e
    
    @transaction.atomic
    def send_message(self, user, message_content, session_id=None):
        """G·ª≠i tin nh·∫Øn v√† l∆∞u v√†o c∆° s·ªü d·ªØ li·ªáu"""
        try:
            # T√¨m ho·∫∑c t·∫°o phi√™n chat
            if session_id:
                try:
                    chat_session = GeminiChatSession.objects.get(id=session_id, user=user)
                except GeminiChatSession.DoesNotExist:
                    chat_session = self.create_chat_session(user)
            else:
                # T√¨m phi√™n chat g·∫ßn nh·∫•t ch∆∞a k·∫øt th√∫c c·ªßa user
                chat_session = GeminiChatSession.objects.filter(
                    user=user,
                    is_ended=False
                ).order_by('-created_at').first()
                
                if not chat_session:
                    chat_session = self.create_chat_session(user)
                
            # L∆∞u tin nh·∫Øn c·ªßa ng∆∞·ªùi d√πng
            user_message = GeminiChatMessage.objects.create(
                chat_session=chat_session,
                role="user",
                content=message_content
            )
            
            # Ph√¢n t√≠ch v√† x·ª≠ l√Ω y√™u c·∫ßu ƒë·ªÉ x√°c ƒë·ªãnh ngu·ªìn d·ªØ li·ªáu
            response_data = self._process_query(message_content, user)
            
            # L∆∞u ph·∫£n h·ªìi c·ªßa AI
            ai_message = GeminiChatMessage.objects.create(
                chat_session=chat_session,
                role="assistant", 
                content=response_data["content"]
            )
            
            # Format timestamp theo ƒë·ªãnh d·∫°ng Vi·ªát Nam
            def format_timestamp(timestamp):
                return timestamp.strftime("%d/%m/%Y %H:%M:%S")
            
            # C·∫≠p nh·∫≠t ti√™u ƒë·ªÅ phi√™n chat n·∫øu c·∫ßn
            if chat_session.title == "Phi√™n chat m·ªõi" and len(message_content) > 10:
                try:
                    # S·ª≠ d·ª•ng Gemini API ƒë·ªÉ t·∫°o ti√™u ƒë·ªÅ th√¥ng minh
                    title = self.generate_chat_title(message_content)
                    chat_session.title = title
                    chat_session.save()
                except Exception as e:
                    self.logger.error(f"L·ªói khi t·∫°o ti√™u ƒë·ªÅ th√¥ng minh: {str(e)}")
                    # Fallback to simple title creation
                    if len(message_content) <= 50:
                        title = message_content
                    else:
                        words = message_content.split()
                        if len(words) <= 8:
                            title = message_content[:50] + '...' 
                        else:
                            title = ' '.join(words[:8]) + '...'
                            
                    chat_session.title = title
                    chat_session.save()
            
            # Tr·∫£ v·ªÅ th√¥ng tin tin nh·∫Øn v√† phi√™n chat
            return {
                "session_id": chat_session.id,
                "title": chat_session.title,
                "user_message": {
                    "id": str(user_message.id),
                    "content": user_message.content,
                    "timestamp": format_timestamp(user_message.timestamp)
                },
                "assistant_message": {
                    "id": str(ai_message.id),
                    "content": ai_message.content,
                    "source_type": response_data["source_type"],
                    "timestamp": format_timestamp(ai_message.timestamp)
                }
            }
            
        except Exception as e:
            self.logger.error(f"L·ªói khi g·ª≠i tin nh·∫Øn: {str(e)}")
            return {
                "error": f"ƒê√£ x·∫£y ra l·ªói: {str(e)}"
            }
    
    def _process_query(self, message_content, user):
        """
        Ph√¢n t√≠ch y√™u c·∫ßu v√† quy·∫øt ƒë·ªãnh x·ª≠ l√Ω b·∫±ng d·ªØ li·ªáu t·ª´ database hay AI
        Tr·∫£ v·ªÅ m·ªôt dict c√≥:
        - content: N·ªôi dung c√¢u tr·∫£ l·ªùi
        - source_type: Lo·∫°i ngu·ªìn d·ªØ li·ªáu ("database", "web", "ai")
        """
        # Ph√¢n t√≠ch t·ª´ kh√≥a v√† √Ω ƒë·ªãnh trong tin nh·∫Øn
        database_query_keywords = [
            "t√¨m vi·ªác", "vi·ªác l√†m", "c√¥ng vi·ªác", "tuy·ªÉn d·ª•ng", "v·ªã tr√≠", "th√¥ng tin c√¥ng ty",
            "m·ª©c l∆∞∆°ng", "th·ªëng k√™", "·ª©ng vi√™n", "nh√† tuy·ªÉn d·ª•ng", "ng√†nh ngh·ªÅ", "kinh nghi·ªám",
            "trong h·ªá th·ªëng", "tr√™n trang web", "hi·ªán c√≥", "ƒëang tuy·ªÉn"
        ]
        
        cv_interview_keywords = [
            "cv", "resume", "curriculum vitae", "s∆° y·∫øu l√Ω l·ªãch",
            "ph·ªèng v·∫•n", "interview", "c√°ch vi·∫øt", "m·∫´u cv",
            "k·ªπ nƒÉng", "skill", "kinh nghi·ªám l√†m vi·ªác",
            "portfolio", "h·ªì s∆°", "·ª©ng tuy·ªÉn", "vi·∫øt ƒë∆°n"
        ]
        
        # Ki·ªÉm tra xem tin nh·∫Øn c√≥ y√™u c·∫ßu truy v·∫•n database kh√¥ng
        is_database_query = any(keyword in message_content.lower() for keyword in database_query_keywords)
        
        # Ki·ªÉm tra xem tin nh·∫Øn c√≥ li√™n quan ƒë·∫øn CV/ph·ªèng v·∫•n kh√¥ng
        is_cv_query = any(keyword in message_content.lower() for keyword in cv_interview_keywords)
        
        # Truy v·∫•n database n·∫øu c√≥ y√™u c·∫ßu
        database_data = None
        if is_database_query:
            database_data = self._process_database_queries(message_content, user)
        
        # Quy·∫øt ƒë·ªãnh ngu·ªìn d·ªØ li·ªáu v√† t·∫°o ph·∫£n h·ªìi
        if database_data:
            # N·∫øu c√≥ d·ªØ li·ªáu t·ª´ database, s·ª≠ d·ª•ng d·ªØ li·ªáu ƒë√≥
            content = self.process_response(None, database_data)
            source_type = "database"
        elif is_cv_query:
            # N·∫øu li√™n quan ƒë·∫øn CV/ph·ªèng v·∫•n, s·ª≠ d·ª•ng t√¨m ki·∫øm web/internet
            content = self._process_web_query(message_content)
            source_type = "web"
        else:
            # S·ª≠ d·ª•ng AI ƒë·ªÉ tr·∫£ l·ªùi c√¢u h·ªèi t·ªïng qu√°t
            content = self._process_ai_query(message_content)
            source_type = "ai"
        
        return {
            "content": content,
            "source_type": source_type
        }
    
    def _process_web_query(self, message_content):
        """X·ª≠ l√Ω truy v·∫•n b·∫±ng c√°ch t√¨m ki·∫øm th√¥ng tin tr√™n web"""
        try:
            # Kh·ªüi t·∫°o model Gemini
            model = self._initialize_generative_model()
            
            # T·∫°o prompt ph√π h·ª£p cho truy v·∫•n web
            prompt = f"""H√£y cung c·∫•p th√¥ng tin c·∫≠p nh·∫≠t v·ªÅ: {message_content}
            
            Y√™u c·∫ßu:
            1. Tr·∫£ l·ªùi b·∫±ng ti·∫øng Vi·ªát
            2. ƒê∆∞a ra c√°c g·ª£i √Ω v√† h∆∞·ªõng d·∫´n c·ª• th·ªÉ
            3. Format c√¢u tr·∫£ l·ªùi d·ªÖ ƒë·ªçc v·ªõi markdown
            4. T·∫≠p trung v√†o c√°c best practices v√† kinh nghi·ªám th·ª±c t·∫ø
            5. ƒê√°nh d·∫•u r√µ r√†ng r·∫±ng ƒë√¢y l√† th√¥ng tin t·ª´ web
            """
            
            # G·ªçi API
            response = model.generate_content(
                prompt,
                generation_config=self.generation_config,
                safety_settings=self.safety_settings
            )
            
            # Th√™m nh√£n ngu·ªìn v√†o ph·∫£n h·ªìi
            web_response = f"""### Th√¥ng tin t·ª´ internet:

{response.text}

*L∆∞u √Ω: Th√¥ng tin tr√™n ƒë∆∞·ª£c t·ªïng h·ª£p t·ª´ internet v√† c√≥ th·ªÉ thay ƒë·ªïi theo th·ªùi gian.*"""
            
            return web_response
            
        except Exception as e:
            self.logger.error(f"L·ªói khi x·ª≠ l√Ω truy v·∫•n web: {str(e)}")
            return "Xin l·ªói, t√¥i kh√¥ng th·ªÉ t√¨m th·∫•y th√¥ng tin ph√π h·ª£p cho y√™u c·∫ßu c·ªßa b·∫°n."
    
    def _process_ai_query(self, message_content):
        """X·ª≠ l√Ω truy v·∫•n b·∫±ng AI t·ªïng qu√°t"""
        try:
            # Kh·ªüi t·∫°o model Gemini
            model = self._initialize_generative_model()
            
            # T·∫°o prompt cho c√¢u h·ªèi t·ªïng qu√°t
            prompt = f"""H√£y tr·∫£ l·ªùi c√¢u h·ªèi sau: {message_content}
            
            Y√™u c·∫ßu:
            1. Tr·∫£ l·ªùi b·∫±ng ti·∫øng Vi·ªát
            2. C√¢u tr·∫£ l·ªùi ph·∫£i ng·∫Øn g·ªçn, d·ªÖ hi·ªÉu
            3. Format c√¢u tr·∫£ l·ªùi d·ªÖ ƒë·ªçc
            4. Tr·∫£ l·ªùi ch√≠nh x√°c, kh√°ch quan
            """
            
            # G·ªçi API
            response = model.generate_content(
                prompt,
                generation_config=self.generation_config,
                safety_settings=self.safety_settings
            )
            
            return response.text
            
        except Exception as e:
            self.logger.error(f"L·ªói khi x·ª≠ l√Ω truy v·∫•n AI: {str(e)}")
            return "Xin l·ªói, t√¥i kh√¥ng th·ªÉ x·ª≠ l√Ω y√™u c·∫ßu c·ªßa b·∫°n l√∫c n√†y. Vui l√≤ng th·ª≠ l·∫°i sau."
    
    def _initialize_generative_model(self):
        """Kh·ªüi t·∫°o model Gemini"""
        return genai.GenerativeModel(
            model_name=self.model_name,
            generation_config=self.generation_config,
            safety_settings=self.safety_settings
        )
    
    def _process_database_queries(self, message_content, user):
        """X·ª≠ l√Ω truy v·∫•n c∆° s·ªü d·ªØ li·ªáu d·ª±a tr√™n n·ªôi dung tin nh·∫Øn"""
        # X·ª≠ l√Ω logic truy v·∫•n database ·ªü ƒë√¢y
        return None
    
    def process_response(self, text, database_data=None):
        """X·ª≠ l√Ω ph·∫£n h·ªìi t·ª´ Gemini API ho·∫∑c database"""
        if database_data:
            return f"""D·ª±a tr√™n d·ªØ li·ªáu c·ªßa h·ªá th·ªëng JobHub:

{database_data}"""
        return text
    
    def _format_chat_history(self, chat_history):
        """Format l·ªãch s·ª≠ tr√≤ chuy·ªán ƒë·ªÉ ƒë∆∞a v√†o prompt"""
        formatted_history = ""
        for message in chat_history:
            role = "User" if message.role == "user" else "Assistant"
            formatted_history += f"{role}: {message.content}\n\n"
        return formatted_history
        
    def generate_chat_title(self, message_content):
        """T·∫°o ti√™u ƒë·ªÅ th√¥ng minh cho phi√™n chat d·ª±a tr√™n n·ªôi dung tin nh·∫Øn ƒë·∫ßu ti√™n"""
        try:
            # Kh·ªüi t·∫°o model
            model = self._initialize_generative_model()
            
            # T·∫°o prompt ƒë·ªÉ sinh ti√™u ƒë·ªÅ
            prompt = f"""Tin nh·∫Øn: "{message_content}"
            
            H√£y t·∫°o m·ªôt ti√™u ƒë·ªÅ ng·∫Øn g·ªçn (d∆∞·ªõi 50 k√Ω t·ª±) cho cu·ªôc tr√≤ chuy·ªán n√†y.
            Ch·ªâ tr·∫£ v·ªÅ ti√™u ƒë·ªÅ, kh√¥ng c√≥ gi·∫£i th√≠ch hay ƒë·ªãnh d·∫°ng th√™m.
            Ti√™u ƒë·ªÅ ph·∫£i b·∫±ng ti·∫øng Vi·ªát v√† m√¥ t·∫£ ng·∫Øn g·ªçn n·ªôi dung ch√≠nh c·ªßa tin nh·∫Øn.
            """
            
            # G·ªçi API v·ªõi c·∫•u h√¨nh temperature th·∫•p h∆°n ƒë·ªÉ c√≥ k·∫øt qu·∫£ ·ªïn ƒë·ªãnh
            title_config = self.generation_config.copy()
            title_config["temperature"] = 0.1
            title_config["max_output_tokens"] = 50
            
            response = model.generate_content(
                prompt,
                generation_config=title_config,
                safety_settings=self.safety_settings
            )
            
            # L√†m s·∫°ch ti√™u ƒë·ªÅ
            title = response.text.strip().replace('"', '').replace('\n', ' ')
            
            # Gi·ªõi h·∫°n ƒë·ªô d√†i ti√™u ƒë·ªÅ
            if len(title) > 50:
                title = title[:47] + '...'
                
            return title
            
        except Exception as e:
            self.logger.error(f"L·ªói khi t·∫°o ti√™u ƒë·ªÅ th√¥ng minh: {str(e)}")
            # Fallback to simple title creation
            if len(message_content) <= 50:
                return message_content
            else:
                words = message_content.split()
                if len(words) <= 8:
                    return message_content[:50] + '...'
                else:
                    return ' '.join(words[:8]) + '...'